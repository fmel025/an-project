
# This file was generated by the Tkinter Designer by Parth Jadhav
# https://github.com/ParthJadhav/Tkinter-Designer

# importaciones-------------------------------------------------------------
from pathlib import Path
from tkinter import *
from tkinter import Tk, Canvas, Entry, Text, Button, PhotoImage, messagebox
from tkinter import filedialog
import pandas as pd
import sympy as sp
import numpy as np
import os as os
from pylatex import Document, Section, Subsection, Command, Alignat, Figure, Tabu
from pylatex import Math, TikZ, Axis, Plot, Figure, Matrix, Alignat 
from pylatex.utils import italic, NoEscape
from mpl_toolkits import mplot3d
import matplotlib.pyplot as plt
from math import *
from tabulate import tabulate

# diseño bases del proyecto
def open_simpson_window(root):
    OUTPUT_PATH = Path(__file__).parent
    ASSETS_PATH = OUTPUT_PATH / Path("./simpson_assets")


    def relative_to_assets(path: str) -> Path:
        return ASSETS_PATH / Path(path)

    window = Toplevel(root)
    window.geometry("400x600")
    window.configure(bg="#FFFFFF")
    window.title("Metodo de integracion de Simpson")
    window.grab_set()
    # declarando--------------------------------
    funcion = StringVar(window)
    intervalos = StringVar(window)
    XlimiteSuperior = StringVar(window)
    XlimiteInferior = StringVar(window)
    YlimiteSuperior = StringVar(window)
    YlimiteInferior = StringVar(window)
    ZlimiteSuperior = StringVar(window)
    ZlimiteInferior = StringVar(window)
    ecuacionPrincipal = StringVar(window)
    respuesta = StringVar(window)
    # funciones------------------------------------------------------------------

    # Llamar simpson intervalos pares


    def Simpson13(a, b, n, f):
        # Es n+1 ya que son n+1 puntos en x segun el numero de intervalos
        x = np.linspace(a, b, n+1)
        intervals = n
        h = (b - a) / intervals
        values = [f(i) for i in x]
        oddSum = 0
        evenSum = 0
        for i in range(1, intervals):
            if i % 2 != 0:
                oddSum += values[i]
            else:
                evenSum += values[i]
        I = (h/3)*(values[0]+4*oddSum + (2*evenSum) + values[intervals])
        print(I)
        return I

    # llamando a simpson multivariable


    def Simpson13_M(variables, limits, intervals, f):
        # AuxF sera la funcion en la cual se evaluara el metodo de simpson 1/3, se evalua en el orden de las variables

        if intervals % 2 != 0:
            raise Exception("El metodo necesita un numero de intervalos par")

        auxF = f

        # Representa la posicion en el arreglo de los limites de la variable en cuestion
        i = 0

        for var in variables:
            auxF = sp.lambdify(var, auxF, modules=["sympy"])
            auxF = Simpson13(limits[i][0], limits[i][1], intervals, auxF)
            i += 1
        return float(auxF)
    # simpson 3/8


    def Simpson38(a, b, intervals, f):
        h = (b - a)/intervals
        x = np.linspace(a, b, intervals + 1)
        values = [f(i) for i in x]
        suma = values[0] + values[-1]
        for j in range(1, intervals):
            if j % 3 == 0:
                suma += 2 * values[j]
            else:
                suma += 3*values[j]
        integration = (3/8)*h*suma
        return integration

    # Para integrales dobles o triples, f es una funcion simbolica


    def Simpson38_M(variables, limits, intervals, f):
        # AuxF sera la funcion en la cual se evaluara el metodo de simpson 3/8, se evalua en el orden de las variables
        auxF = f
        # Representa la posicion en el arreglo de los limites de la variable en cuestion
        i = 0
        for var in variables:
            auxF = sp.lambdify(var, auxF, modules=["sympy"])
            auxF = Simpson38(limits[i][0], limits[i][1], intervals, auxF)
            i += 1
        return float(auxF)

    # para crear una tabla


    def create_dictionary(columns):
        dictionary = {}
        for c in columns:
            dictionary[c] = []
        return dictionary

    # Funcion para añadir datos en una columna


    def add_info(dictionary, columns, data):
        i = 0
        for c in columns:
            dictionary[c].append(data[i])
            i += 1

    # llamando con boton calcular--------------------------------------------

    def get_path():
            dir_path = filedialog.askdirectory(
                title="Seleccione un directorio para almacenar el reporte")
            return dir_path


    def generate_pdf_single(ecuacionPrincipal, respuesta, intervals, a, b, f):
        # Creando el documento PDF basado en Latex agregandole tablas y datos
        x = np.linspace(a, b, intervals + 1)
        x = x.tolist()
        y = [f(i) for i in x]
        values = list(zip(x, y))

        geometry_options = {"tmargin": "1.5in", "lmargin": "1.5in"}
        pdfFilename=""
        path_to_save = get_path()
        if path_to_save == "":
            return
        pdfFilename = os.path.join(path_to_save, "SimpsonReport")
        doc = Document(pdfFilename, geometry_options=geometry_options)
        doc.preamble.append(Command("title", "Metodo Simpson 1/3 y 3/8"))
        doc.preamble.append(
            Command("author", "Stephensen Methodverse of madness"))
        doc.append(NoEscape(r'\maketitle'))
        with doc.create(Section('Funcion')):
            doc.append('Aqui tenemos nuestra funcion ')
            with doc.create(Alignat(numbering=False, escape=False)) as ecuacion:
                ecuacion.append(ecuacionPrincipal)
            with doc.create(Subsection('Respuesta')):
                doc.append("aqui tenemos nuestra respuesta que es = {")
                doc.append(respuesta)
                doc.append("} u")
            with doc.create(Subsection('Grafica de la funcion por Simpson')): 
                with doc.create(TikZ()): 
                    plot_options = 'height=4cm, width=6cm, grid=major'
                    with doc.create(Axis(options=plot_options)) as plot: 
                        plot.append(Plot(name='Funcion', coordinates=values))
                
        doc.generate_pdf(clean_tex=False, compiler="pdflatex")
        doc.generate_tex()
        messagebox.showinfo("Generado", "Se ha generado el archivo PDF")

    def generate_pdf(ecuacionPrincipal, respuesta):
        # Creando el documento PDF basado en Latex agregandole tablas y datos
        geometry_options = {"tmargin": "1.5in", "lmargin": "1.5in"}
        pdfFilename=""
        path_to_save = get_path()
        if path_to_save == "":
            return
        pdfFilename = os.path.join(path_to_save, "SimpsonReport")
        doc = Document(pdfFilename, geometry_options=geometry_options)
        doc.preamble.append(Command("title", "Metodo Simpson 1/3 y 3/8"))
        doc.preamble.append(
            Command("author", "Stephensen Methodverse of madness"))
        doc.append(NoEscape(r'\maketitle'))
        with doc.create(Section('Funcion')):
            doc.append('Aqui tenemos nuestra funcion ')
            with doc.create(Alignat(numbering=False, escape=False)) as ecuacion:
                ecuacion.append(ecuacionPrincipal)
            with doc.create(Subsection('Respuesta')):
                doc.append("aqui tenemos nuestra respuesta que es = {")
                doc.append(respuesta)
                doc.append("} u")
        doc.generate_pdf(clean_tex=False, compiler="pdflatex")
        doc.generate_tex()
        messagebox.showinfo("Generado", "Se ha generado el archivo PDF")

    def HandlerSimpson13():
        if str(funcion.get()) == "" and str(intervalos.get()) == "" and str(XlimiteSuperior.get()) == "":
            messagebox.showwarning("ERROR", "te faltan parametros por llenar")
            return

        messagebox.showinfo("INFO", "Calculando...")
            # llamando a simpson integral simple
        if YlimiteInferior.get() == "" and ZlimiteInferior.get() == "" and XlimiteInferior.get() != "":
            b = int(XlimiteSuperior.get())
            a = int(XlimiteInferior.get())
            def f(x): return eval(funcion.get(), {'x': x})
            if a <= b:
                intervals = int(intervalos.get())
                respuesta = 0
                if intervals % 2 == 0:
                    messagebox.showinfo(
                        "En marcha", "Aplicando Simpson 1/3 par esta integral")
                    respuesta = Simpson13(a, b, intervals, f)
                else:
                    messagebox.showinfo(
                        "En marcha", "Aplicando Simpson 3/8 par esta integral")
                    respuesta = Simpson38(a, b, intervals, f)
    # haciendo la ecuacion de funcion principal
                bGrag = str(XlimiteSuperior.get())
                aGrag = str(XlimiteInferior.get())
                fGraf = str(funcion.get())
                ecuacionPrincipal = "\int_{"+aGrag + \
                    "}^{"+bGrag + "}" + fGraf + " dx"
                generate_pdf_single(ecuacionPrincipal, respuesta, intervals, a, b, f)

            else:
                messagebox.showwarning(
                    "ERROR", "es posible que tus limites no esten bien")
                return


    # ll    amando a simpson integral doble----------------------------------------------------------------------
        if XlimiteInferior.get() != "" and YlimiteInferior.get() != "" and ZlimiteInferior.get() == "":
            x = sp.Symbol("x")
            y = sp.Symbol("y")
            b = int(XlimiteSuperior.get())
            a = int(XlimiteInferior.get())
            c = int(YlimiteInferior.get())
            d = int(YlimiteSuperior.get())
            if a <= b and c <= d:
                function = sp.sympify(funcion.get())
                variables = [x, y]
                limits = np.array([[a, b], [c, d]])
                intervals = int(intervalos.get())
                respuesta = 0
                if intervals % 2 == 0:
                    messagebox.showinfo(
                        "En marcha", "aplicando Simpson1/3 multivariable par esta integral")
                    respuesta = Simpson13_M(
                        variables, limits, intervals, function)
                else:
                    messagebox.showinfo(
                        "En marcha", "aplicando Simpson3/8 multivariable par esta integral")
                    respuesta = Simpson38_M(
                        variables, limits, intervals, function)
                    # haciendo la ecuacion de funcion principal
                bGrag = str(XlimiteSuperior.get())
                aGrag = str(XlimiteInferior.get())
                cGrag = str(YlimiteInferior.get())
                dGrag = str(YlimiteSuperior.get())
                fGraf = str(funcion.get())
                ecuacionPrincipal = "\int_{"+cGrag+"}^{"+dGrag + \
                    "}\int_{" + aGrag + "}^{"+bGrag + "}" + fGraf + " dx dy"
                generate_pdf(ecuacionPrincipal, respuesta)
            else:
                messagebox.showwarning(
                    "ERROR", "es posible que tus limites no esten bien")
                return


    # ll    amando a simpson integral triple con validaciones----------------------------------------------------------------------------
        if XlimiteInferior.get() != "" and ZlimiteInferior.get() != "" and YlimiteInferior.get() != "":
            x = sp.Symbol("x")
            y = sp.Symbol("y")
            z = sp.Symbol("z")
            b = int(XlimiteSuperior.get())
            a = int(XlimiteInferior.get())
            c = int(YlimiteInferior.get())
            d = int(YlimiteSuperior.get())
            f = int(ZlimiteSuperior.get())
            e = int(ZlimiteInferior.get())
            if a <= b and c <= d and e <= f:
                function = sp.sympify(funcion.get())
                variables = [x, y, z]
                limits = np.array([[a, b], [c, d], [e, f]])
                intervals = int(intervalos.get())
                respuesta = 0
                if intervals % 2 == 0:
                    messagebox.showinfo(
                        "En marcha", "aplicando Simpson1/3 multivariable par esta integral")
                    respuesta = Simpson13_M(
                        variables, limits, intervals, function)
                else:
                    messagebox.showinfo(
                        "En marcha", "aplicando Simpson3/8 multivariable par esta integral")
                    respuesta = Simpson38_M(
                        variables, limits, intervals, function)
                    # haciendo la ecuacion de funcion principal

                # haciendo la ecuacion de funcion principal

                bGrag = str(XlimiteSuperior.get())
                aGrag = str(XlimiteInferior.get())
                cGrag = str(YlimiteInferior.get())
                dGrag = str(YlimiteSuperior.get())
                eGrag = str(ZlimiteInferior.get())
                fGrag = str(ZlimiteSuperior.get())
                fGraf = str(funcion.get())
                ecuacionPrincipal = "\int_{"+cGrag+"}^{"+dGrag + \
                "}\int_{" + aGrag + "}^{"+bGrag + "}"+ "\int_{" + eGrag + "}^{"+fGrag + "}" + fGraf + " \ dx dy dz"
                generate_pdf(ecuacionPrincipal, respuesta)
            else:
                messagebox.showwarning(
                    "ERROR", "es posible que tus limites no esten bien")
                return
            

    # funcionalidad de los botones de integrales------------------------------
    # habilitando solo una integral------


    def integral():
        entry_8.delete(0, END)
        entry_4.delete(0, END)
        entry_3.delete(0, END)
        entry_2.delete(0, END)
        entry_1.config(state='normal')
        entry_5.config(state='normal')
        entry_8.config(state='disabled')
        entry_4.config(state='disabled')
        entry_3.config(state='disabled')
        entry_2.config(state='disabled')

    # habilitando solo la doble integral------


    def integralDoble():
        entry_4.delete(0, END)
        entry_2.delete(0, END)
        entry_1.config(state='normal')
        entry_5.config(state='normal')
        entry_8.config(state='normal')
        entry_4.config(state='disabled')
        entry_3.config(state='normal')
        entry_2.config(state='disabled')


    def integralTriple():
        entry_1.config(state='normal')
        entry_5.config(state='normal')
        entry_8.config(state='normal')
        entry_4.config(state='normal')
        entry_3.config(state='normal')
        entry_2.config(state='normal')
        entry_2.config(state='normal')
        entry_4.config(state='normal')


    # Diseño importado de Herramienta Designer--------------------------------
    canvas = Canvas(
        window,
        bg="#FFFFFF",
        height=600,
        width=400,
        bd=0,
        highlightthickness=0,
        relief="ridge"
    )

    canvas.place(x=0, y=0)
    canvas.create_rectangle(
        0.0,
        0.0,
        400.0,
        600.0,
        fill="#C9DBEC",
        outline="")


    # entradas superior de x
    entry_1 = Entry(
        window,
        bd=0,
        textvar=XlimiteSuperior,
        bg="#FFFFFF",
        state='disabled',
        highlightthickness=0
    )
    entry_1.place(
        x=45.0,
        y=233.0,
        width=83.0,
        height=37.0
    )


    # limite z superior
    entry_2 = Entry(
        window,
        bd=0,
        bg="#FFFFFF",
        state='disabled',
        textvar=ZlimiteSuperior,
        highlightthickness=0
    )
    entry_2.place(
        x=273.0,
        y=233.0,
        width=82.0,
        height=37.0
    )


    # limite y inferior
    entry_3 = Entry(
        window,
        bd=0,
        bg="#FFFFFF",
        state='disabled',
        textvar=YlimiteInferior,
        highlightthickness=0
    )
    entry_3.place(
        x=159.0,
        y=280.0,
        width=82.0,
        height=37.0
    )


    # limite de z inferior
    entry_4 = Entry(
        window,
        bd=0,
        bg="#FFFFFF",
        state='disabled',
        textvar=ZlimiteInferior,
        highlightthickness=0
    )
    entry_4.place(
        x=273.0,
        y=280.0,
        width=82.0,
        height=37.0
    )


    # limite x inferior
    entry_5 = Entry(
        window,
        bd=0,
        textvar=XlimiteInferior,
        bg="#FFFFFF",
        state='disabled',
        highlightthickness=0
    )
    entry_5.place(
        x=45.0,
        y=280.0,
        width=83.0,
        height=37.0
    )


    # meter funcion
    entry_6 = Entry(
        window,
        bd=0,
        bg="#FFFFFF",
        textvar=funcion,
        highlightthickness=0
    )
    entry_6.place(
        x=47.0,
        y=361.0,
        width=310.0,
        height=37.0
    )


    # intervalos
    entry_7 = Entry(
        window,
        bd=0,
        bg="#FFFFFF",
        textvar=intervalos,
        highlightthickness=0
    )
    entry_7.place(
        x=45.0,
        y=442.0,
        width=310.0,
        height=37.0
    )

    canvas.create_text(
        70.0,
        22.0,
        anchor="nw",
        text="Simpson",
        fill="#FFFFFF",
        font=("Bold", 35 * -2)
    )

    # boton calcular
    button_image_1 = PhotoImage(
        file=relative_to_assets("button_1.png"))
    button_1 = Button(
        window,
        image=button_image_1,
        borderwidth=0,
        highlightthickness=0,
        command=HandlerSimpson13,
        relief="flat"
    )
    button_1.place(
        x=41.0,
        y=503.0,
        width=319.0,
        height=66.0
    )

    canvas.create_text(
        47.0,
        211.0,
        anchor="nw",
        text="limites",
        fill="#003A95",
        font=("Bold", 13)
    )

    canvas.create_text(
        47.0,
        339.0,
        anchor="nw",
        text="Funcion para python",
        fill="#003A95",
        font=("Bold", 12)
    )

    canvas.create_text(
        47.0,
        420.0,
        anchor="nw",
        text="intervalos",
        fill="#003A95",
        font=("Bold", 14)
    )

    canvas.create_text(
        47.0,
        114.0,
        anchor="nw",
        text="Tipo de integral",
        fill="#003A95",
        font=("Bold", 13)
    )

    # boton integral simple
    button_image_2 = PhotoImage(
        file=relative_to_assets("button_2.png"))
    button_2 = Button(
        window,
        image=button_image_2,
        borderwidth=0,
        highlightthickness=0,
        command=integral,
        relief="flat"
    )
    button_2.place(
        x=45.0,
        y=141.0,
        width=83.0,
        height=49.0
    )

    # boton integral doble
    button_image_3 = PhotoImage(
        file=relative_to_assets("button_3.png"))
    button_3 = Button(
        window,
        image=button_image_3,
        borderwidth=0,
        highlightthickness=0,
        command=integralDoble,
        relief="flat"
    )
    button_3.place(
        x=159.0,
        y=141.0,
        width=83.0,
        height=49.0
    )

    # boton integral triple
    button_image_4 = PhotoImage(
        file=relative_to_assets("button_4.png"))
    button_4 = Button(
        window,
        image=button_image_4,
        borderwidth=0,
        highlightthickness=0,
        command=integralTriple,
        relief="flat"
    )
    button_4.place(
        x=273.0,
        y=141.0,
        width=83.0,
        height=49.0
    )


    # limite superior y
    entry_8 = Entry(
        window,
        bd=0,
        bg="#FFFFFF",
        state='disabled',
        textvar=YlimiteSuperior,
        highlightthickness=0
    )
    entry_8.place(
        x=159.0,
        y=233.0,
        width=82.0,
        height=37.0
    )

    window.resizable(False, False)
    window.mainloop()
